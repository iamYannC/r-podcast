Strategy for Issue #5 (Export formats: XLSX + SQLite)

Context snapshot structure (from outputs/snapshots/*.rds):
- meta: tibble with episode_slug, episode_nr, title, publish_date (Date), duration (hms), episode_url, audio_url, podhome_uuid
- transcripts: tibble with episode_slug, podhome_uuid, transcript_url, full_transcript
- chapters: tibble with episode_slug, chapter_title, chapter_url, chapter_ts
- descriptions: list with two tibbles
  - descriptions: episode_slug, description_text
  - description_links: episode_slug, section, text, link

Decisions + reasoning

1) Script locations
Decision: add a new script under build-scripts/export_formats.R and a tiny top-level wrapper export_all.R.
Reason: build-scripts/ already hosts all data production logic, so keeping export logic there is consistent with existing layout; a top-level wrapper mirrors build_all.R for easy user entry without forcing them to dig into build-scripts/.

2) Public functions
Decision: expose three main functions:
- load_latest_snapshot(snapshot_dir = "outputs/snapshots")
- normalize_for_export(snapshot)
- export_snapshot(snapshot, out_dir = "outputs/exports", basename = NULL, write_latest = TRUE, max_xlsx_chars = 32000)
Reason: separating load/normalize/export keeps logic composable; normalization lets XLSX + SQLite share the same cleaned data; export_snapshot centralizes file naming and output conventions.

3) Output location and naming
Decision: write exports to outputs/exports with date-stamped filenames (snapshot_YYYY-MM-DD.xlsx / snapshot_YYYY-MM-DD.sqlite) and optionally write/overwrite latest.xlsx and latest.sqlite.
Reason: outputs/ already houses generated data; a dedicated exports subdir avoids mixing RDS with exports; date stamps preserve history; latest.* enables quick consumption without manual filename discovery.

4) Data contract for export (tables)
Decision: export five tables/sheets: meta, transcripts, chapters, descriptions, description_links.
Reason: these match the canonical snapshot structure; keeping them separate preserves normalization and avoids row duplication from joins.

5) Column normalization (shared across formats)
Decision: normalize types before export:
- publish_date => ISO-8601 string (YYYY-MM-DD)
- duration (hms) => duration_seconds (numeric) and duration_hms (HH:MM:SS string)
- chapter_ts => chapter_ts_seconds (numeric) and chapter_ts_hms (string)
- ensure character columns are UTF-8
Reason: SQLite has weak type handling for Date/hms; XLSX often mis-displays R Date/hms; dual columns preserve both human readability and numeric analysis; explicit UTF-8 avoids encoding surprises.

6) Primary keys and indexes for SQLite
Decision: create tables with episode_slug as the logical key and add indexes on episode_slug and podhome_uuid where present.
Reason: episode_slug is already the stable join key across tables; indexing improves common joins without forcing a full schema migration or complicated surrogate keys.

7) XLSX strategy
Decision: build a multi-sheet workbook using writexl::write_xlsx(list(meta=..., transcripts=..., chapters=..., descriptions=..., description_links=...)).
Reason: writexl is a light dependency (no Java), easy to use, and fits a single-call export pipeline; multiple sheets preserve table boundaries for end users.

8) Handling long transcripts in XLSX
Decision: include full_transcript but add transcript_length and optionally truncate to max_xlsx_chars with a note column transcript_truncated = TRUE/FALSE.
Reason: Excel has a per-cell character limit; explicit truncation avoids silent data loss while keeping the workbook usable; a flag makes the limitation transparent.

9) SQLite strategy
Decision: use DBI + RSQLite to create a single .sqlite file with five tables; write with DBI::dbWriteTable(..., overwrite=TRUE) and wrap in a transaction.
Reason: DBI/RSQLite is the standard R approach; overwrite keeps exports deterministic; a transaction avoids partially-written databases if a write fails.

10) Validation and logging
Decision: add a lightweight validation step in export_snapshot:
- check required columns exist
- warn if any table has 0 rows
- warn if any transcript truncation occurs
Reason: exporters should fail fast on schema drift; warnings help users trust outputs without being too noisy.

11) How it ties into existing workflow
Decision: keep exports optional and triggered manually (export_all.R) or by CI as a separate step after update.R.
Reason: build_all/update.R already write RDS and snapshots; decoupling exports avoids changing core scraping logic and reduces risk of breaking existing flows.

Proposed function signatures (draft)
- load_latest_snapshot(snapshot_dir = "outputs/snapshots")
  - finds latest snapshot_*.rds by mtime and returns the list.
- normalize_for_export(snapshot)
  - returns a list of 5 tibbles with normalized columns as described.
- export_snapshot(snapshot, out_dir = "outputs/exports", basename = NULL, write_latest = TRUE, max_xlsx_chars = 32000)
  - uses normalize_for_export
  - writes XLSX and SQLite
  - returns a list with file paths and any warnings

Suggested file contents (high-level)
- build-scripts/export_formats.R
  - load_latest_snapshot()
  - normalize_for_export()
  - .normalize_meta(), .normalize_transcripts(), .normalize_chapters(), .normalize_descriptions()
  - export_xlsx(tables, path, max_xlsx_chars)
  - export_sqlite(tables, path)
  - export_snapshot()
- export_all.R
  - source("build-scripts/export_formats.R")
  - snapshot <- load_latest_snapshot()
  - export_snapshot(snapshot)

Reasoning for helper split
Decision: keep small, private helpers per table.
Reason: schema changes are localized; adding new columns later will touch only one helper, lowering maintenance cost.

Reasoning for minimal dependencies
Decision: use writexl, DBI, RSQLite only.
Reason: avoids Java (openxlsx) and heavy packages; easiest install path for users.

Reasoning for not modifying build_all.R yet
Decision: do not auto-export inside build_all by default (maybe optional parameter later).
Reason: keeps existing users unaffected; exports can be introduced safely without changing current behavior.

Edge cases to account for in implementation
- descriptions may be a single tibble (older outputs) vs list: normalize to list with both tibbles.
- NA chapter_url or link should remain NULL/NA in outputs.
- If latest snapshot missing, allow passing a snapshot object explicitly (export_snapshot accepts object directly).

Acceptance criteria (what done looks like)
- Running export_all.R creates outputs/exports/snapshot_YYYY-MM-DD.xlsx and .sqlite.
- XLSX has 5 sheets with expected columns and any truncation flags.
- SQLite has 5 tables with indexes and ISO-formatted dates.
- No changes to existing RDS or snapshots.
